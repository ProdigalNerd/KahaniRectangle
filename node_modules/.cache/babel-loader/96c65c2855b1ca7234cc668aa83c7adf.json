{"ast":null,"code":"import _classCallCheck from \"/Users/tylerwilson/Documents/GitHub/KahaniRectangle/kahani-rectangle/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tylerwilson/Documents/GitHub/KahaniRectangle/kahani-rectangle/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/tylerwilson/Documents/GitHub/KahaniRectangle/kahani-rectangle/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tylerwilson/Documents/GitHub/KahaniRectangle/kahani-rectangle/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Util } from '../Util.js';\nimport { Factory } from '../Factory.js';\nimport { Shape } from '../Shape.js';\nimport { Path } from './Path.js';\nimport { Text, stringToArray } from './Text.js';\nimport { getNumberValidator } from '../Validators.js';\nimport { _registerNode } from '../Global.js';\nvar EMPTY_STRING = '',\n  NORMAL = 'normal';\nfunction _fillFunc(context) {\n  context.fillText(this.partialText, 0, 0);\n}\nfunction _strokeFunc(context) {\n  context.strokeText(this.partialText, 0, 0);\n}\nexport var TextPath = /*#__PURE__*/function (_Shape) {\n  _inherits(TextPath, _Shape);\n  var _super = _createSuper(TextPath);\n  function TextPath(config) {\n    var _this;\n    _classCallCheck(this, TextPath);\n    _this = _super.call(this, config);\n    _this.dummyCanvas = Util.createCanvasElement();\n    _this.dataArray = [];\n    _this.dataArray = Path.parsePathData(_this.attrs.data);\n    _this.on('dataChange.konva', function () {\n      this.dataArray = Path.parsePathData(this.attrs.data);\n      this._setTextData();\n    });\n    _this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva', _this._setTextData);\n    _this._setTextData();\n    return _this;\n  }\n  _createClass(TextPath, [{\n    key: \"_sceneFunc\",\n    value: function _sceneFunc(context) {\n      context.setAttr('font', this._getContextFont());\n      context.setAttr('textBaseline', this.textBaseline());\n      context.setAttr('textAlign', 'left');\n      context.save();\n      var textDecoration = this.textDecoration();\n      var fill = this.fill();\n      var fontSize = this.fontSize();\n      var glyphInfo = this.glyphInfo;\n      if (textDecoration === 'underline') {\n        context.beginPath();\n      }\n      for (var i = 0; i < glyphInfo.length; i++) {\n        context.save();\n        var p0 = glyphInfo[i].p0;\n        context.translate(p0.x, p0.y);\n        context.rotate(glyphInfo[i].rotation);\n        this.partialText = glyphInfo[i].text;\n        context.fillStrokeShape(this);\n        if (textDecoration === 'underline') {\n          if (i === 0) {\n            context.moveTo(0, fontSize / 2 + 1);\n          }\n          context.lineTo(fontSize, fontSize / 2 + 1);\n        }\n        context.restore();\n      }\n      if (textDecoration === 'underline') {\n        context.strokeStyle = fill;\n        context.lineWidth = fontSize / 20;\n        context.stroke();\n      }\n      context.restore();\n    }\n  }, {\n    key: \"_hitFunc\",\n    value: function _hitFunc(context) {\n      context.beginPath();\n      var glyphInfo = this.glyphInfo;\n      if (glyphInfo.length >= 1) {\n        var p0 = glyphInfo[0].p0;\n        context.moveTo(p0.x, p0.y);\n      }\n      for (var i = 0; i < glyphInfo.length; i++) {\n        var p1 = glyphInfo[i].p1;\n        context.lineTo(p1.x, p1.y);\n      }\n      context.setAttr('lineWidth', this.fontSize());\n      context.setAttr('strokeStyle', this.colorKey);\n      context.stroke();\n    }\n  }, {\n    key: \"getTextWidth\",\n    value: function getTextWidth() {\n      return this.textWidth;\n    }\n  }, {\n    key: \"getTextHeight\",\n    value: function getTextHeight() {\n      Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n      return this.textHeight;\n    }\n  }, {\n    key: \"setText\",\n    value: function setText(text) {\n      return Text.prototype.setText.call(this, text);\n    }\n  }, {\n    key: \"_getContextFont\",\n    value: function _getContextFont() {\n      return Text.prototype._getContextFont.call(this);\n    }\n  }, {\n    key: \"_getTextSize\",\n    value: function _getTextSize(text) {\n      var dummyCanvas = this.dummyCanvas;\n      var _context = dummyCanvas.getContext('2d');\n      _context.save();\n      _context.font = this._getContextFont();\n      var metrics = _context.measureText(text);\n      _context.restore();\n      return {\n        width: metrics.width,\n        height: parseInt(this.attrs.fontSize, 10)\n      };\n    }\n  }, {\n    key: \"_setTextData\",\n    value: function _setTextData() {\n      var that = this;\n      var size = this._getTextSize(this.attrs.text);\n      var letterSpacing = this.letterSpacing();\n      var align = this.align();\n      var kerningFunc = this.kerningFunc();\n      this.textWidth = size.width;\n      this.textHeight = size.height;\n      var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n      this.glyphInfo = [];\n      var fullPathWidth = 0;\n      for (var l = 0; l < that.dataArray.length; l++) {\n        if (that.dataArray[l].pathLength > 0) {\n          fullPathWidth += that.dataArray[l].pathLength;\n        }\n      }\n      var offset = 0;\n      if (align === 'center') {\n        offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n      }\n      if (align === 'right') {\n        offset = Math.max(0, fullPathWidth - textFullWidth);\n      }\n      var charArr = stringToArray(this.text());\n      var spacesNumber = this.text().split(' ').length - 1;\n      var p0, p1, pathCmd;\n      var pIndex = -1;\n      var currentT = 0;\n      var getNextPathSegment = function getNextPathSegment() {\n        currentT = 0;\n        var pathData = that.dataArray;\n        for (var j = pIndex + 1; j < pathData.length; j++) {\n          if (pathData[j].pathLength > 0) {\n            pIndex = j;\n            return pathData[j];\n          } else if (pathData[j].command === 'M') {\n            p0 = {\n              x: pathData[j].points[0],\n              y: pathData[j].points[1]\n            };\n          }\n        }\n        return {};\n      };\n      var findSegmentToFitCharacter = function findSegmentToFitCharacter(c) {\n        var glyphWidth = that._getTextSize(c).width + letterSpacing;\n        if (c === ' ' && align === 'justify') {\n          glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n        }\n        var currLen = 0;\n        var attempts = 0;\n        p1 = undefined;\n        while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 && attempts < 20) {\n          attempts++;\n          var cumulativePathLength = currLen;\n          while (pathCmd === undefined) {\n            pathCmd = getNextPathSegment();\n            if (pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n              cumulativePathLength += pathCmd.pathLength;\n              pathCmd = undefined;\n            }\n          }\n          if (Object.keys(pathCmd).length === 0 || p0 === undefined) {\n            return undefined;\n          }\n          var needNewSegment = false;\n          switch (pathCmd.command) {\n            case 'L':\n              if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n                p1 = Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n              } else {\n                pathCmd = undefined;\n              }\n              break;\n            case 'A':\n              var start = pathCmd.points[4];\n              var dTheta = pathCmd.points[5];\n              var end = pathCmd.points[4] + dTheta;\n              if (currentT === 0) {\n                currentT = start + 0.00000001;\n              } else if (glyphWidth > currLen) {\n                currentT += Math.PI / 180.0 * dTheta / Math.abs(dTheta);\n              } else {\n                currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);\n              }\n              if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n                currentT = end;\n                needNewSegment = true;\n              }\n              p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n              break;\n            case 'C':\n              if (currentT === 0) {\n                if (glyphWidth > pathCmd.pathLength) {\n                  currentT = 0.00000001;\n                } else {\n                  currentT = glyphWidth / pathCmd.pathLength;\n                }\n              } else if (glyphWidth > currLen) {\n                currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n              } else {\n                currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n              }\n              if (currentT > 1.0) {\n                currentT = 1.0;\n                needNewSegment = true;\n              }\n              p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n              break;\n            case 'Q':\n              if (currentT === 0) {\n                currentT = glyphWidth / pathCmd.pathLength;\n              } else if (glyphWidth > currLen) {\n                currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n              } else {\n                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n              }\n              if (currentT > 1.0) {\n                currentT = 1.0;\n                needNewSegment = true;\n              }\n              p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n              break;\n          }\n          if (p1 !== undefined) {\n            currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n          }\n          if (needNewSegment) {\n            needNewSegment = false;\n            pathCmd = undefined;\n          }\n        }\n      };\n      var testChar = 'C';\n      var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n      var lettersInOffset = offset / glyphWidth - 1;\n      for (var k = 0; k < lettersInOffset; k++) {\n        findSegmentToFitCharacter(testChar);\n        if (p0 === undefined || p1 === undefined) {\n          break;\n        }\n        p0 = p1;\n      }\n      for (var i = 0; i < charArr.length; i++) {\n        findSegmentToFitCharacter(charArr[i]);\n        if (p0 === undefined || p1 === undefined) {\n          break;\n        }\n        var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n        var kern = 0;\n        if (kerningFunc) {\n          try {\n            kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n          } catch (e) {\n            kern = 0;\n          }\n        }\n        p0.x += kern;\n        p1.x += kern;\n        this.textWidth += kern;\n        var midpoint = Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n        var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n        this.glyphInfo.push({\n          transposeX: midpoint.x,\n          transposeY: midpoint.y,\n          text: charArr[i],\n          rotation: rotation,\n          p0: p0,\n          p1: p1\n        });\n        p0 = p1;\n      }\n    }\n  }, {\n    key: \"getSelfRect\",\n    value: function getSelfRect() {\n      if (!this.glyphInfo.length) {\n        return {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      var points = [];\n      this.glyphInfo.forEach(function (info) {\n        points.push(info.p0.x);\n        points.push(info.p0.y);\n        points.push(info.p1.x);\n        points.push(info.p1.y);\n      });\n      var minX = points[0] || 0;\n      var maxX = points[0] || 0;\n      var minY = points[1] || 0;\n      var maxY = points[1] || 0;\n      var x, y;\n      for (var i = 0; i < points.length / 2; i++) {\n        x = points[i * 2];\n        y = points[i * 2 + 1];\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n      }\n      var fontSize = this.fontSize();\n      return {\n        x: minX - fontSize / 2,\n        y: minY - fontSize / 2,\n        width: maxX - minX + fontSize,\n        height: maxY - minY + fontSize\n      };\n    }\n  }]);\n  return TextPath;\n}(Shape);\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\n_registerNode(TextPath);\nFactory.addGetterSetter(TextPath, 'data');\nFactory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory.addGetterSetter(TextPath, 'fontSize', 12, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory.addGetterSetter(TextPath, 'align', 'left');\nFactory.addGetterSetter(TextPath, 'letterSpacing', 0, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory.addGetterSetter(TextPath, 'kerningFunc', null);","map":{"version":3,"names":["Util","Factory","Shape","Path","Text","stringToArray","getNumberValidator","_registerNode","EMPTY_STRING","NORMAL","_fillFunc","context","fillText","partialText","_strokeFunc","strokeText","TextPath","config","dummyCanvas","createCanvasElement","dataArray","parsePathData","attrs","data","on","_setTextData","setAttr","_getContextFont","textBaseline","save","textDecoration","fill","fontSize","glyphInfo","beginPath","i","length","p0","translate","x","y","rotate","rotation","text","fillStrokeShape","moveTo","lineTo","restore","strokeStyle","lineWidth","stroke","p1","colorKey","textWidth","warn","textHeight","prototype","setText","call","_context","getContext","font","metrics","measureText","width","height","parseInt","that","size","_getTextSize","letterSpacing","align","kerningFunc","textFullWidth","Math","max","fullPathWidth","l","pathLength","offset","charArr","spacesNumber","split","pathCmd","pIndex","currentT","getNextPathSegment","pathData","j","command","points","findSegmentToFitCharacter","c","glyphWidth","currLen","attempts","undefined","abs","cumulativePathLength","Object","keys","needNewSegment","getLineLength","getPointOnLine","start","dTheta","end","PI","getPointOnEllipticalArc","getPointOnCubicBezier","getPointOnQuadraticBezier","testChar","lettersInOffset","k","kern","e","midpoint","atan2","push","transposeX","transposeY","forEach","info","minX","maxX","minY","maxY","min","_fillFuncHit","_strokeFuncHit","className","_attrsAffectingSize","addGetterSetter"],"sources":["/Users/tylerwilson/Documents/GitHub/KahaniRectangle/kahani-rectangle/node_modules/konva/lib/shapes/TextPath.js"],"sourcesContent":["import { Util } from '../Util.js';\nimport { Factory } from '../Factory.js';\nimport { Shape } from '../Shape.js';\nimport { Path } from './Path.js';\nimport { Text, stringToArray } from './Text.js';\nimport { getNumberValidator } from '../Validators.js';\nimport { _registerNode } from '../Global.js';\nvar EMPTY_STRING = '', NORMAL = 'normal';\nfunction _fillFunc(context) {\n    context.fillText(this.partialText, 0, 0);\n}\nfunction _strokeFunc(context) {\n    context.strokeText(this.partialText, 0, 0);\n}\nexport class TextPath extends Shape {\n    constructor(config) {\n        super(config);\n        this.dummyCanvas = Util.createCanvasElement();\n        this.dataArray = [];\n        this.dataArray = Path.parsePathData(this.attrs.data);\n        this.on('dataChange.konva', function () {\n            this.dataArray = Path.parsePathData(this.attrs.data);\n            this._setTextData();\n        });\n        this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva', this._setTextData);\n        this._setTextData();\n    }\n    _sceneFunc(context) {\n        context.setAttr('font', this._getContextFont());\n        context.setAttr('textBaseline', this.textBaseline());\n        context.setAttr('textAlign', 'left');\n        context.save();\n        var textDecoration = this.textDecoration();\n        var fill = this.fill();\n        var fontSize = this.fontSize();\n        var glyphInfo = this.glyphInfo;\n        if (textDecoration === 'underline') {\n            context.beginPath();\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            context.save();\n            var p0 = glyphInfo[i].p0;\n            context.translate(p0.x, p0.y);\n            context.rotate(glyphInfo[i].rotation);\n            this.partialText = glyphInfo[i].text;\n            context.fillStrokeShape(this);\n            if (textDecoration === 'underline') {\n                if (i === 0) {\n                    context.moveTo(0, fontSize / 2 + 1);\n                }\n                context.lineTo(fontSize, fontSize / 2 + 1);\n            }\n            context.restore();\n        }\n        if (textDecoration === 'underline') {\n            context.strokeStyle = fill;\n            context.lineWidth = fontSize / 20;\n            context.stroke();\n        }\n        context.restore();\n    }\n    _hitFunc(context) {\n        context.beginPath();\n        var glyphInfo = this.glyphInfo;\n        if (glyphInfo.length >= 1) {\n            var p0 = glyphInfo[0].p0;\n            context.moveTo(p0.x, p0.y);\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            var p1 = glyphInfo[i].p1;\n            context.lineTo(p1.x, p1.y);\n        }\n        context.setAttr('lineWidth', this.fontSize());\n        context.setAttr('strokeStyle', this.colorKey);\n        context.stroke();\n    }\n    getTextWidth() {\n        return this.textWidth;\n    }\n    getTextHeight() {\n        Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n        return this.textHeight;\n    }\n    setText(text) {\n        return Text.prototype.setText.call(this, text);\n    }\n    _getContextFont() {\n        return Text.prototype._getContextFont.call(this);\n    }\n    _getTextSize(text) {\n        var dummyCanvas = this.dummyCanvas;\n        var _context = dummyCanvas.getContext('2d');\n        _context.save();\n        _context.font = this._getContextFont();\n        var metrics = _context.measureText(text);\n        _context.restore();\n        return {\n            width: metrics.width,\n            height: parseInt(this.attrs.fontSize, 10),\n        };\n    }\n    _setTextData() {\n        var that = this;\n        var size = this._getTextSize(this.attrs.text);\n        var letterSpacing = this.letterSpacing();\n        var align = this.align();\n        var kerningFunc = this.kerningFunc();\n        this.textWidth = size.width;\n        this.textHeight = size.height;\n        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n        this.glyphInfo = [];\n        var fullPathWidth = 0;\n        for (var l = 0; l < that.dataArray.length; l++) {\n            if (that.dataArray[l].pathLength > 0) {\n                fullPathWidth += that.dataArray[l].pathLength;\n            }\n        }\n        var offset = 0;\n        if (align === 'center') {\n            offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n        }\n        if (align === 'right') {\n            offset = Math.max(0, fullPathWidth - textFullWidth);\n        }\n        var charArr = stringToArray(this.text());\n        var spacesNumber = this.text().split(' ').length - 1;\n        var p0, p1, pathCmd;\n        var pIndex = -1;\n        var currentT = 0;\n        var getNextPathSegment = function () {\n            currentT = 0;\n            var pathData = that.dataArray;\n            for (var j = pIndex + 1; j < pathData.length; j++) {\n                if (pathData[j].pathLength > 0) {\n                    pIndex = j;\n                    return pathData[j];\n                }\n                else if (pathData[j].command === 'M') {\n                    p0 = {\n                        x: pathData[j].points[0],\n                        y: pathData[j].points[1],\n                    };\n                }\n            }\n            return {};\n        };\n        var findSegmentToFitCharacter = function (c) {\n            var glyphWidth = that._getTextSize(c).width + letterSpacing;\n            if (c === ' ' && align === 'justify') {\n                glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n            }\n            var currLen = 0;\n            var attempts = 0;\n            p1 = undefined;\n            while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&\n                attempts < 20) {\n                attempts++;\n                var cumulativePathLength = currLen;\n                while (pathCmd === undefined) {\n                    pathCmd = getNextPathSegment();\n                    if (pathCmd &&\n                        cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n                        cumulativePathLength += pathCmd.pathLength;\n                        pathCmd = undefined;\n                    }\n                }\n                if (Object.keys(pathCmd).length === 0 || p0 === undefined) {\n                    return undefined;\n                }\n                var needNewSegment = false;\n                switch (pathCmd.command) {\n                    case 'L':\n                        if (Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n                            p1 = Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n                        }\n                        else {\n                            pathCmd = undefined;\n                        }\n                        break;\n                    case 'A':\n                        var start = pathCmd.points[4];\n                        var dTheta = pathCmd.points[5];\n                        var end = pathCmd.points[4] + dTheta;\n                        if (currentT === 0) {\n                            currentT = start + 0.00000001;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += ((Math.PI / 180.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        else {\n                            currentT -= ((Math.PI / 360.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        if ((dTheta < 0 && currentT < end) ||\n                            (dTheta >= 0 && currentT > end)) {\n                            currentT = end;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n                        break;\n                    case 'C':\n                        if (currentT === 0) {\n                            if (glyphWidth > pathCmd.pathLength) {\n                                currentT = 0.00000001;\n                            }\n                            else {\n                                currentT = glyphWidth / pathCmd.pathLength;\n                            }\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n                        }\n                        else {\n                            currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n                        break;\n                    case 'Q':\n                        if (currentT === 0) {\n                            currentT = glyphWidth / pathCmd.pathLength;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n                        }\n                        else {\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n                        break;\n                }\n                if (p1 !== undefined) {\n                    currLen = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                }\n                if (needNewSegment) {\n                    needNewSegment = false;\n                    pathCmd = undefined;\n                }\n            }\n        };\n        var testChar = 'C';\n        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n        var lettersInOffset = offset / glyphWidth - 1;\n        for (var k = 0; k < lettersInOffset; k++) {\n            findSegmentToFitCharacter(testChar);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            p0 = p1;\n        }\n        for (var i = 0; i < charArr.length; i++) {\n            findSegmentToFitCharacter(charArr[i]);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            var width = Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n            var kern = 0;\n            if (kerningFunc) {\n                try {\n                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n                }\n                catch (e) {\n                    kern = 0;\n                }\n            }\n            p0.x += kern;\n            p1.x += kern;\n            this.textWidth += kern;\n            var midpoint = Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n            var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n            this.glyphInfo.push({\n                transposeX: midpoint.x,\n                transposeY: midpoint.y,\n                text: charArr[i],\n                rotation: rotation,\n                p0: p0,\n                p1: p1,\n            });\n            p0 = p1;\n        }\n    }\n    getSelfRect() {\n        if (!this.glyphInfo.length) {\n            return {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0,\n            };\n        }\n        var points = [];\n        this.glyphInfo.forEach(function (info) {\n            points.push(info.p0.x);\n            points.push(info.p0.y);\n            points.push(info.p1.x);\n            points.push(info.p1.y);\n        });\n        var minX = points[0] || 0;\n        var maxX = points[0] || 0;\n        var minY = points[1] || 0;\n        var maxY = points[1] || 0;\n        var x, y;\n        for (var i = 0; i < points.length / 2; i++) {\n            x = points[i * 2];\n            y = points[i * 2 + 1];\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        }\n        var fontSize = this.fontSize();\n        return {\n            x: minX - fontSize / 2,\n            y: minY - fontSize / 2,\n            width: maxX - minX + fontSize,\n            height: maxY - minY + fontSize,\n        };\n    }\n}\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\n_registerNode(TextPath);\nFactory.addGetterSetter(TextPath, 'data');\nFactory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory.addGetterSetter(TextPath, 'fontSize', 12, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory.addGetterSetter(TextPath, 'align', 'left');\nFactory.addGetterSetter(TextPath, 'letterSpacing', 0, getNumberValidator());\nFactory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory.addGetterSetter(TextPath, 'kerningFunc', null);\n"],"mappings":";;;;AAAA,SAASA,IAAI,QAAQ,YAAY;AACjC,SAASC,OAAO,QAAQ,eAAe;AACvC,SAASC,KAAK,QAAQ,aAAa;AACnC,SAASC,IAAI,QAAQ,WAAW;AAChC,SAASC,IAAI,EAAEC,aAAa,QAAQ,WAAW;AAC/C,SAASC,kBAAkB,QAAQ,kBAAkB;AACrD,SAASC,aAAa,QAAQ,cAAc;AAC5C,IAAIC,YAAY,GAAG,EAAE;EAAEC,MAAM,GAAG,QAAQ;AACxC,SAASC,SAAS,CAACC,OAAO,EAAE;EACxBA,OAAO,CAACC,QAAQ,CAAC,IAAI,CAACC,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC;AAC5C;AACA,SAASC,WAAW,CAACH,OAAO,EAAE;EAC1BA,OAAO,CAACI,UAAU,CAAC,IAAI,CAACF,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC;AAC9C;AACA,WAAaG,QAAQ;EAAA;EAAA;EACjB,kBAAYC,MAAM,EAAE;IAAA;IAAA;IAChB,0BAAMA,MAAM;IACZ,MAAKC,WAAW,GAAGlB,IAAI,CAACmB,mBAAmB,EAAE;IAC7C,MAAKC,SAAS,GAAG,EAAE;IACnB,MAAKA,SAAS,GAAGjB,IAAI,CAACkB,aAAa,CAAC,MAAKC,KAAK,CAACC,IAAI,CAAC;IACpD,MAAKC,EAAE,CAAC,kBAAkB,EAAE,YAAY;MACpC,IAAI,CAACJ,SAAS,GAAGjB,IAAI,CAACkB,aAAa,CAAC,IAAI,CAACC,KAAK,CAACC,IAAI,CAAC;MACpD,IAAI,CAACE,YAAY,EAAE;IACvB,CAAC,CAAC;IACF,MAAKD,EAAE,CAAC,kIAAkI,EAAE,MAAKC,YAAY,CAAC;IAC9J,MAAKA,YAAY,EAAE;IAAC;EACxB;EAAC;IAAA;IAAA,OACD,oBAAWd,OAAO,EAAE;MAChBA,OAAO,CAACe,OAAO,CAAC,MAAM,EAAE,IAAI,CAACC,eAAe,EAAE,CAAC;MAC/ChB,OAAO,CAACe,OAAO,CAAC,cAAc,EAAE,IAAI,CAACE,YAAY,EAAE,CAAC;MACpDjB,OAAO,CAACe,OAAO,CAAC,WAAW,EAAE,MAAM,CAAC;MACpCf,OAAO,CAACkB,IAAI,EAAE;MACd,IAAIC,cAAc,GAAG,IAAI,CAACA,cAAc,EAAE;MAC1C,IAAIC,IAAI,GAAG,IAAI,CAACA,IAAI,EAAE;MACtB,IAAIC,QAAQ,GAAG,IAAI,CAACA,QAAQ,EAAE;MAC9B,IAAIC,SAAS,GAAG,IAAI,CAACA,SAAS;MAC9B,IAAIH,cAAc,KAAK,WAAW,EAAE;QAChCnB,OAAO,CAACuB,SAAS,EAAE;MACvB;MACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,SAAS,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;QACvCxB,OAAO,CAACkB,IAAI,EAAE;QACd,IAAIQ,EAAE,GAAGJ,SAAS,CAACE,CAAC,CAAC,CAACE,EAAE;QACxB1B,OAAO,CAAC2B,SAAS,CAACD,EAAE,CAACE,CAAC,EAAEF,EAAE,CAACG,CAAC,CAAC;QAC7B7B,OAAO,CAAC8B,MAAM,CAACR,SAAS,CAACE,CAAC,CAAC,CAACO,QAAQ,CAAC;QACrC,IAAI,CAAC7B,WAAW,GAAGoB,SAAS,CAACE,CAAC,CAAC,CAACQ,IAAI;QACpChC,OAAO,CAACiC,eAAe,CAAC,IAAI,CAAC;QAC7B,IAAId,cAAc,KAAK,WAAW,EAAE;UAChC,IAAIK,CAAC,KAAK,CAAC,EAAE;YACTxB,OAAO,CAACkC,MAAM,CAAC,CAAC,EAAEb,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;UACvC;UACArB,OAAO,CAACmC,MAAM,CAACd,QAAQ,EAAEA,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;QAC9C;QACArB,OAAO,CAACoC,OAAO,EAAE;MACrB;MACA,IAAIjB,cAAc,KAAK,WAAW,EAAE;QAChCnB,OAAO,CAACqC,WAAW,GAAGjB,IAAI;QAC1BpB,OAAO,CAACsC,SAAS,GAAGjB,QAAQ,GAAG,EAAE;QACjCrB,OAAO,CAACuC,MAAM,EAAE;MACpB;MACAvC,OAAO,CAACoC,OAAO,EAAE;IACrB;EAAC;IAAA;IAAA,OACD,kBAASpC,OAAO,EAAE;MACdA,OAAO,CAACuB,SAAS,EAAE;MACnB,IAAID,SAAS,GAAG,IAAI,CAACA,SAAS;MAC9B,IAAIA,SAAS,CAACG,MAAM,IAAI,CAAC,EAAE;QACvB,IAAIC,EAAE,GAAGJ,SAAS,CAAC,CAAC,CAAC,CAACI,EAAE;QACxB1B,OAAO,CAACkC,MAAM,CAACR,EAAE,CAACE,CAAC,EAAEF,EAAE,CAACG,CAAC,CAAC;MAC9B;MACA,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,SAAS,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;QACvC,IAAIgB,EAAE,GAAGlB,SAAS,CAACE,CAAC,CAAC,CAACgB,EAAE;QACxBxC,OAAO,CAACmC,MAAM,CAACK,EAAE,CAACZ,CAAC,EAAEY,EAAE,CAACX,CAAC,CAAC;MAC9B;MACA7B,OAAO,CAACe,OAAO,CAAC,WAAW,EAAE,IAAI,CAACM,QAAQ,EAAE,CAAC;MAC7CrB,OAAO,CAACe,OAAO,CAAC,aAAa,EAAE,IAAI,CAAC0B,QAAQ,CAAC;MAC7CzC,OAAO,CAACuC,MAAM,EAAE;IACpB;EAAC;IAAA;IAAA,OACD,wBAAe;MACX,OAAO,IAAI,CAACG,SAAS;IACzB;EAAC;IAAA;IAAA,OACD,yBAAgB;MACZrD,IAAI,CAACsD,IAAI,CAAC,2HAA2H,CAAC;MACtI,OAAO,IAAI,CAACC,UAAU;IAC1B;EAAC;IAAA;IAAA,OACD,iBAAQZ,IAAI,EAAE;MACV,OAAOvC,IAAI,CAACoD,SAAS,CAACC,OAAO,CAACC,IAAI,CAAC,IAAI,EAAEf,IAAI,CAAC;IAClD;EAAC;IAAA;IAAA,OACD,2BAAkB;MACd,OAAOvC,IAAI,CAACoD,SAAS,CAAC7B,eAAe,CAAC+B,IAAI,CAAC,IAAI,CAAC;IACpD;EAAC;IAAA;IAAA,OACD,sBAAaf,IAAI,EAAE;MACf,IAAIzB,WAAW,GAAG,IAAI,CAACA,WAAW;MAClC,IAAIyC,QAAQ,GAAGzC,WAAW,CAAC0C,UAAU,CAAC,IAAI,CAAC;MAC3CD,QAAQ,CAAC9B,IAAI,EAAE;MACf8B,QAAQ,CAACE,IAAI,GAAG,IAAI,CAAClC,eAAe,EAAE;MACtC,IAAImC,OAAO,GAAGH,QAAQ,CAACI,WAAW,CAACpB,IAAI,CAAC;MACxCgB,QAAQ,CAACZ,OAAO,EAAE;MAClB,OAAO;QACHiB,KAAK,EAAEF,OAAO,CAACE,KAAK;QACpBC,MAAM,EAAEC,QAAQ,CAAC,IAAI,CAAC5C,KAAK,CAACU,QAAQ,EAAE,EAAE;MAC5C,CAAC;IACL;EAAC;IAAA;IAAA,OACD,wBAAe;MACX,IAAImC,IAAI,GAAG,IAAI;MACf,IAAIC,IAAI,GAAG,IAAI,CAACC,YAAY,CAAC,IAAI,CAAC/C,KAAK,CAACqB,IAAI,CAAC;MAC7C,IAAI2B,aAAa,GAAG,IAAI,CAACA,aAAa,EAAE;MACxC,IAAIC,KAAK,GAAG,IAAI,CAACA,KAAK,EAAE;MACxB,IAAIC,WAAW,GAAG,IAAI,CAACA,WAAW,EAAE;MACpC,IAAI,CAACnB,SAAS,GAAGe,IAAI,CAACJ,KAAK;MAC3B,IAAI,CAACT,UAAU,GAAGa,IAAI,CAACH,MAAM;MAC7B,IAAIQ,aAAa,GAAGC,IAAI,CAACC,GAAG,CAAC,IAAI,CAACtB,SAAS,GAAG,CAAC,CAAC,IAAI,CAAC/B,KAAK,CAACqB,IAAI,IAAI,EAAE,EAAEP,MAAM,GAAG,CAAC,IAAIkC,aAAa,EAAE,CAAC,CAAC;MACtG,IAAI,CAACrC,SAAS,GAAG,EAAE;MACnB,IAAI2C,aAAa,GAAG,CAAC;MACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,IAAI,CAAC/C,SAAS,CAACgB,MAAM,EAAEyC,CAAC,EAAE,EAAE;QAC5C,IAAIV,IAAI,CAAC/C,SAAS,CAACyD,CAAC,CAAC,CAACC,UAAU,GAAG,CAAC,EAAE;UAClCF,aAAa,IAAIT,IAAI,CAAC/C,SAAS,CAACyD,CAAC,CAAC,CAACC,UAAU;QACjD;MACJ;MACA,IAAIC,MAAM,GAAG,CAAC;MACd,IAAIR,KAAK,KAAK,QAAQ,EAAE;QACpBQ,MAAM,GAAGL,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEC,aAAa,GAAG,CAAC,GAAGH,aAAa,GAAG,CAAC,CAAC;MAC/D;MACA,IAAIF,KAAK,KAAK,OAAO,EAAE;QACnBQ,MAAM,GAAGL,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEC,aAAa,GAAGH,aAAa,CAAC;MACvD;MACA,IAAIO,OAAO,GAAG3E,aAAa,CAAC,IAAI,CAACsC,IAAI,EAAE,CAAC;MACxC,IAAIsC,YAAY,GAAG,IAAI,CAACtC,IAAI,EAAE,CAACuC,KAAK,CAAC,GAAG,CAAC,CAAC9C,MAAM,GAAG,CAAC;MACpD,IAAIC,EAAE,EAAEc,EAAE,EAAEgC,OAAO;MACnB,IAAIC,MAAM,GAAG,CAAC,CAAC;MACf,IAAIC,QAAQ,GAAG,CAAC;MAChB,IAAIC,kBAAkB,GAAG,SAArBA,kBAAkB,GAAe;QACjCD,QAAQ,GAAG,CAAC;QACZ,IAAIE,QAAQ,GAAGpB,IAAI,CAAC/C,SAAS;QAC7B,KAAK,IAAIoE,CAAC,GAAGJ,MAAM,GAAG,CAAC,EAAEI,CAAC,GAAGD,QAAQ,CAACnD,MAAM,EAAEoD,CAAC,EAAE,EAAE;UAC/C,IAAID,QAAQ,CAACC,CAAC,CAAC,CAACV,UAAU,GAAG,CAAC,EAAE;YAC5BM,MAAM,GAAGI,CAAC;YACV,OAAOD,QAAQ,CAACC,CAAC,CAAC;UACtB,CAAC,MACI,IAAID,QAAQ,CAACC,CAAC,CAAC,CAACC,OAAO,KAAK,GAAG,EAAE;YAClCpD,EAAE,GAAG;cACDE,CAAC,EAAEgD,QAAQ,CAACC,CAAC,CAAC,CAACE,MAAM,CAAC,CAAC,CAAC;cACxBlD,CAAC,EAAE+C,QAAQ,CAACC,CAAC,CAAC,CAACE,MAAM,CAAC,CAAC;YAC3B,CAAC;UACL;QACJ;QACA,OAAO,CAAC,CAAC;MACb,CAAC;MACD,IAAIC,yBAAyB,GAAG,SAA5BA,yBAAyB,CAAaC,CAAC,EAAE;QACzC,IAAIC,UAAU,GAAG1B,IAAI,CAACE,YAAY,CAACuB,CAAC,CAAC,CAAC5B,KAAK,GAAGM,aAAa;QAC3D,IAAIsB,CAAC,KAAK,GAAG,IAAIrB,KAAK,KAAK,SAAS,EAAE;UAClCsB,UAAU,IAAI,CAACjB,aAAa,GAAGH,aAAa,IAAIQ,YAAY;QAChE;QACA,IAAIa,OAAO,GAAG,CAAC;QACf,IAAIC,QAAQ,GAAG,CAAC;QAChB5C,EAAE,GAAG6C,SAAS;QACd,OAAOtB,IAAI,CAACuB,GAAG,CAACJ,UAAU,GAAGC,OAAO,CAAC,GAAGD,UAAU,GAAG,IAAI,IACrDE,QAAQ,GAAG,EAAE,EAAE;UACfA,QAAQ,EAAE;UACV,IAAIG,oBAAoB,GAAGJ,OAAO;UAClC,OAAOX,OAAO,KAAKa,SAAS,EAAE;YAC1Bb,OAAO,GAAGG,kBAAkB,EAAE;YAC9B,IAAIH,OAAO,IACPe,oBAAoB,GAAGf,OAAO,CAACL,UAAU,GAAGe,UAAU,EAAE;cACxDK,oBAAoB,IAAIf,OAAO,CAACL,UAAU;cAC1CK,OAAO,GAAGa,SAAS;YACvB;UACJ;UACA,IAAIG,MAAM,CAACC,IAAI,CAACjB,OAAO,CAAC,CAAC/C,MAAM,KAAK,CAAC,IAAIC,EAAE,KAAK2D,SAAS,EAAE;YACvD,OAAOA,SAAS;UACpB;UACA,IAAIK,cAAc,GAAG,KAAK;UAC1B,QAAQlB,OAAO,CAACM,OAAO;YACnB,KAAK,GAAG;cACJ,IAAItF,IAAI,CAACmG,aAAa,CAACjE,EAAE,CAACE,CAAC,EAAEF,EAAE,CAACG,CAAC,EAAE2C,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGG,UAAU,EAAE;gBACnF1C,EAAE,GAAGhD,IAAI,CAACoG,cAAc,CAACV,UAAU,EAAExD,EAAE,CAACE,CAAC,EAAEF,EAAE,CAACG,CAAC,EAAE2C,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAErD,EAAE,CAACE,CAAC,EAAEF,EAAE,CAACG,CAAC,CAAC;cACtG,CAAC,MACI;gBACD2C,OAAO,GAAGa,SAAS;cACvB;cACA;YACJ,KAAK,GAAG;cACJ,IAAIQ,KAAK,GAAGrB,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC;cAC7B,IAAIe,MAAM,GAAGtB,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC;cAC9B,IAAIgB,GAAG,GAAGvB,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,GAAGe,MAAM;cACpC,IAAIpB,QAAQ,KAAK,CAAC,EAAE;gBAChBA,QAAQ,GAAGmB,KAAK,GAAG,UAAU;cACjC,CAAC,MACI,IAAIX,UAAU,GAAGC,OAAO,EAAE;gBAC3BT,QAAQ,IAAMX,IAAI,CAACiC,EAAE,GAAG,KAAK,GAAIF,MAAM,GAAI/B,IAAI,CAACuB,GAAG,CAACQ,MAAM,CAAC;cAC/D,CAAC,MACI;gBACDpB,QAAQ,IAAMX,IAAI,CAACiC,EAAE,GAAG,KAAK,GAAIF,MAAM,GAAI/B,IAAI,CAACuB,GAAG,CAACQ,MAAM,CAAC;cAC/D;cACA,IAAKA,MAAM,GAAG,CAAC,IAAIpB,QAAQ,GAAGqB,GAAG,IAC5BD,MAAM,IAAI,CAAC,IAAIpB,QAAQ,GAAGqB,GAAI,EAAE;gBACjCrB,QAAQ,GAAGqB,GAAG;gBACdL,cAAc,GAAG,IAAI;cACzB;cACAlD,EAAE,GAAGhD,IAAI,CAACyG,uBAAuB,CAACzB,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEL,QAAQ,EAAEF,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,CAAC;cAC1I;YACJ,KAAK,GAAG;cACJ,IAAIL,QAAQ,KAAK,CAAC,EAAE;gBAChB,IAAIQ,UAAU,GAAGV,OAAO,CAACL,UAAU,EAAE;kBACjCO,QAAQ,GAAG,UAAU;gBACzB,CAAC,MACI;kBACDA,QAAQ,GAAGQ,UAAU,GAAGV,OAAO,CAACL,UAAU;gBAC9C;cACJ,CAAC,MACI,IAAIe,UAAU,GAAGC,OAAO,EAAE;gBAC3BT,QAAQ,IAAI,CAACQ,UAAU,GAAGC,OAAO,IAAIX,OAAO,CAACL,UAAU,GAAG,CAAC;cAC/D,CAAC,MACI;gBACDO,QAAQ,GAAGX,IAAI,CAACC,GAAG,CAACU,QAAQ,GAAG,CAACS,OAAO,GAAGD,UAAU,IAAIV,OAAO,CAACL,UAAU,GAAG,CAAC,EAAE,CAAC,CAAC;cACtF;cACA,IAAIO,QAAQ,GAAG,GAAG,EAAE;gBAChBA,QAAQ,GAAG,GAAG;gBACdgB,cAAc,GAAG,IAAI;cACzB;cACAlD,EAAE,GAAGhD,IAAI,CAAC0G,qBAAqB,CAACxB,QAAQ,EAAEF,OAAO,CAACqB,KAAK,CAACjE,CAAC,EAAE4C,OAAO,CAACqB,KAAK,CAAChE,CAAC,EAAE2C,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,CAAC;cAC7L;YACJ,KAAK,GAAG;cACJ,IAAIL,QAAQ,KAAK,CAAC,EAAE;gBAChBA,QAAQ,GAAGQ,UAAU,GAAGV,OAAO,CAACL,UAAU;cAC9C,CAAC,MACI,IAAIe,UAAU,GAAGC,OAAO,EAAE;gBAC3BT,QAAQ,IAAI,CAACQ,UAAU,GAAGC,OAAO,IAAIX,OAAO,CAACL,UAAU;cAC3D,CAAC,MACI;gBACDO,QAAQ,IAAI,CAACS,OAAO,GAAGD,UAAU,IAAIV,OAAO,CAACL,UAAU;cAC3D;cACA,IAAIO,QAAQ,GAAG,GAAG,EAAE;gBAChBA,QAAQ,GAAG,GAAG;gBACdgB,cAAc,GAAG,IAAI;cACzB;cACAlD,EAAE,GAAGhD,IAAI,CAAC2G,yBAAyB,CAACzB,QAAQ,EAAEF,OAAO,CAACqB,KAAK,CAACjE,CAAC,EAAE4C,OAAO,CAACqB,KAAK,CAAChE,CAAC,EAAE2C,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,EAAEP,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,CAAC;cAC3J;UAAM;UAEd,IAAIvC,EAAE,KAAK6C,SAAS,EAAE;YAClBF,OAAO,GAAG3F,IAAI,CAACmG,aAAa,CAACjE,EAAE,CAACE,CAAC,EAAEF,EAAE,CAACG,CAAC,EAAEW,EAAE,CAACZ,CAAC,EAAEY,EAAE,CAACX,CAAC,CAAC;UACxD;UACA,IAAI6D,cAAc,EAAE;YAChBA,cAAc,GAAG,KAAK;YACtBlB,OAAO,GAAGa,SAAS;UACvB;QACJ;MACJ,CAAC;MACD,IAAIe,QAAQ,GAAG,GAAG;MAClB,IAAIlB,UAAU,GAAG1B,IAAI,CAACE,YAAY,CAAC0C,QAAQ,CAAC,CAAC/C,KAAK,GAAGM,aAAa;MAClE,IAAI0C,eAAe,GAAGjC,MAAM,GAAGc,UAAU,GAAG,CAAC;MAC7C,KAAK,IAAIoB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,eAAe,EAAEC,CAAC,EAAE,EAAE;QACtCtB,yBAAyB,CAACoB,QAAQ,CAAC;QACnC,IAAI1E,EAAE,KAAK2D,SAAS,IAAI7C,EAAE,KAAK6C,SAAS,EAAE;UACtC;QACJ;QACA3D,EAAE,GAAGc,EAAE;MACX;MACA,KAAK,IAAIhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6C,OAAO,CAAC5C,MAAM,EAAED,CAAC,EAAE,EAAE;QACrCwD,yBAAyB,CAACX,OAAO,CAAC7C,CAAC,CAAC,CAAC;QACrC,IAAIE,EAAE,KAAK2D,SAAS,IAAI7C,EAAE,KAAK6C,SAAS,EAAE;UACtC;QACJ;QACA,IAAIhC,KAAK,GAAG7D,IAAI,CAACmG,aAAa,CAACjE,EAAE,CAACE,CAAC,EAAEF,EAAE,CAACG,CAAC,EAAEW,EAAE,CAACZ,CAAC,EAAEY,EAAE,CAACX,CAAC,CAAC;QACtD,IAAI0E,IAAI,GAAG,CAAC;QACZ,IAAI1C,WAAW,EAAE;UACb,IAAI;YACA0C,IAAI,GAAG1C,WAAW,CAACQ,OAAO,CAAC7C,CAAC,GAAG,CAAC,CAAC,EAAE6C,OAAO,CAAC7C,CAAC,CAAC,CAAC,GAAG,IAAI,CAACH,QAAQ,EAAE;UACpE,CAAC,CACD,OAAOmF,CAAC,EAAE;YACND,IAAI,GAAG,CAAC;UACZ;QACJ;QACA7E,EAAE,CAACE,CAAC,IAAI2E,IAAI;QACZ/D,EAAE,CAACZ,CAAC,IAAI2E,IAAI;QACZ,IAAI,CAAC7D,SAAS,IAAI6D,IAAI;QACtB,IAAIE,QAAQ,GAAGjH,IAAI,CAACoG,cAAc,CAACW,IAAI,GAAGlD,KAAK,GAAG,GAAG,EAAE3B,EAAE,CAACE,CAAC,EAAEF,EAAE,CAACG,CAAC,EAAEW,EAAE,CAACZ,CAAC,EAAEY,EAAE,CAACX,CAAC,CAAC;QAC9E,IAAIE,QAAQ,GAAGgC,IAAI,CAAC2C,KAAK,CAAClE,EAAE,CAACX,CAAC,GAAGH,EAAE,CAACG,CAAC,EAAEW,EAAE,CAACZ,CAAC,GAAGF,EAAE,CAACE,CAAC,CAAC;QACnD,IAAI,CAACN,SAAS,CAACqF,IAAI,CAAC;UAChBC,UAAU,EAAEH,QAAQ,CAAC7E,CAAC;UACtBiF,UAAU,EAAEJ,QAAQ,CAAC5E,CAAC;UACtBG,IAAI,EAAEqC,OAAO,CAAC7C,CAAC,CAAC;UAChBO,QAAQ,EAAEA,QAAQ;UAClBL,EAAE,EAAEA,EAAE;UACNc,EAAE,EAAEA;QACR,CAAC,CAAC;QACFd,EAAE,GAAGc,EAAE;MACX;IACJ;EAAC;IAAA;IAAA,OACD,uBAAc;MACV,IAAI,CAAC,IAAI,CAAClB,SAAS,CAACG,MAAM,EAAE;QACxB,OAAO;UACHG,CAAC,EAAE,CAAC;UACJC,CAAC,EAAE,CAAC;UACJwB,KAAK,EAAE,CAAC;UACRC,MAAM,EAAE;QACZ,CAAC;MACL;MACA,IAAIyB,MAAM,GAAG,EAAE;MACf,IAAI,CAACzD,SAAS,CAACwF,OAAO,CAAC,UAAUC,IAAI,EAAE;QACnChC,MAAM,CAAC4B,IAAI,CAACI,IAAI,CAACrF,EAAE,CAACE,CAAC,CAAC;QACtBmD,MAAM,CAAC4B,IAAI,CAACI,IAAI,CAACrF,EAAE,CAACG,CAAC,CAAC;QACtBkD,MAAM,CAAC4B,IAAI,CAACI,IAAI,CAACvE,EAAE,CAACZ,CAAC,CAAC;QACtBmD,MAAM,CAAC4B,IAAI,CAACI,IAAI,CAACvE,EAAE,CAACX,CAAC,CAAC;MAC1B,CAAC,CAAC;MACF,IAAImF,IAAI,GAAGjC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;MACzB,IAAIkC,IAAI,GAAGlC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;MACzB,IAAImC,IAAI,GAAGnC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;MACzB,IAAIoC,IAAI,GAAGpC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;MACzB,IAAInD,CAAC,EAAEC,CAAC;MACR,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuD,MAAM,CAACtD,MAAM,GAAG,CAAC,EAAED,CAAC,EAAE,EAAE;QACxCI,CAAC,GAAGmD,MAAM,CAACvD,CAAC,GAAG,CAAC,CAAC;QACjBK,CAAC,GAAGkD,MAAM,CAACvD,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QACrBwF,IAAI,GAAGjD,IAAI,CAACqD,GAAG,CAACJ,IAAI,EAAEpF,CAAC,CAAC;QACxBqF,IAAI,GAAGlD,IAAI,CAACC,GAAG,CAACiD,IAAI,EAAErF,CAAC,CAAC;QACxBsF,IAAI,GAAGnD,IAAI,CAACqD,GAAG,CAACF,IAAI,EAAErF,CAAC,CAAC;QACxBsF,IAAI,GAAGpD,IAAI,CAACC,GAAG,CAACmD,IAAI,EAAEtF,CAAC,CAAC;MAC5B;MACA,IAAIR,QAAQ,GAAG,IAAI,CAACA,QAAQ,EAAE;MAC9B,OAAO;QACHO,CAAC,EAAEoF,IAAI,GAAG3F,QAAQ,GAAG,CAAC;QACtBQ,CAAC,EAAEqF,IAAI,GAAG7F,QAAQ,GAAG,CAAC;QACtBgC,KAAK,EAAE4D,IAAI,GAAGD,IAAI,GAAG3F,QAAQ;QAC7BiC,MAAM,EAAE6D,IAAI,GAAGD,IAAI,GAAG7F;MAC1B,CAAC;IACL;EAAC;EAAA;AAAA,EArTyB9B,KAAK;AAuTnCc,QAAQ,CAACwC,SAAS,CAAC9C,SAAS,GAAGA,SAAS;AACxCM,QAAQ,CAACwC,SAAS,CAAC1C,WAAW,GAAGA,WAAW;AAC5CE,QAAQ,CAACwC,SAAS,CAACwE,YAAY,GAAGtH,SAAS;AAC3CM,QAAQ,CAACwC,SAAS,CAACyE,cAAc,GAAGnH,WAAW;AAC/CE,QAAQ,CAACwC,SAAS,CAAC0E,SAAS,GAAG,UAAU;AACzClH,QAAQ,CAACwC,SAAS,CAAC2E,mBAAmB,GAAG,CAAC,MAAM,EAAE,UAAU,EAAE,MAAM,CAAC;AACrE5H,aAAa,CAACS,QAAQ,CAAC;AACvBf,OAAO,CAACmI,eAAe,CAACpH,QAAQ,EAAE,MAAM,CAAC;AACzCf,OAAO,CAACmI,eAAe,CAACpH,QAAQ,EAAE,YAAY,EAAE,OAAO,CAAC;AACxDf,OAAO,CAACmI,eAAe,CAACpH,QAAQ,EAAE,UAAU,EAAE,EAAE,EAAEV,kBAAkB,EAAE,CAAC;AACvEL,OAAO,CAACmI,eAAe,CAACpH,QAAQ,EAAE,WAAW,EAAEP,MAAM,CAAC;AACtDR,OAAO,CAACmI,eAAe,CAACpH,QAAQ,EAAE,OAAO,EAAE,MAAM,CAAC;AAClDf,OAAO,CAACmI,eAAe,CAACpH,QAAQ,EAAE,eAAe,EAAE,CAAC,EAAEV,kBAAkB,EAAE,CAAC;AAC3EL,OAAO,CAACmI,eAAe,CAACpH,QAAQ,EAAE,cAAc,EAAE,QAAQ,CAAC;AAC3Df,OAAO,CAACmI,eAAe,CAACpH,QAAQ,EAAE,aAAa,EAAEP,MAAM,CAAC;AACxDR,OAAO,CAACmI,eAAe,CAACpH,QAAQ,EAAE,MAAM,EAAER,YAAY,CAAC;AACvDP,OAAO,CAACmI,eAAe,CAACpH,QAAQ,EAAE,gBAAgB,EAAE,IAAI,CAAC;AACzDf,OAAO,CAACmI,eAAe,CAACpH,QAAQ,EAAE,aAAa,EAAE,IAAI,CAAC"},"metadata":{},"sourceType":"module"}